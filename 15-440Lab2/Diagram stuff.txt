Figure 1 shows a simplified diagram of how a lookup works in our RMI implementation.  Let's say that Client A wants to run a method using a remote object on Client B.  First Client B must have placed the object's information in the registry server using bind, then Client A can do a lookup to get that information, using the RegistryMessage class to communicate back and forth.  The information returned by the lookup is converted by the RMIRegistryClient object into a RemoteObjectRef object, which is then localised into a Proxy with InvocationHandler RMIProxyHandler.  This handler marshalls all the method invocations into RMIMessage objects and sends them to Client B's dispatcher (RMIProxy).  The dispatcher then unmarshalls the message and spawns a thread to handle the local function call (RMIProxySlave).  The slave dereferences any remote object references passed as arguments to the method, finds the target object in the local remote object table, and excecutes the method.  Then it converts the return values to remote object references and marshalls them into a RMIMessage, which it then sends back to Client A's proxy.  The proxy then unmarshalls the message, dereferences any remote object references, and either returns the result or throws returned exceptions.